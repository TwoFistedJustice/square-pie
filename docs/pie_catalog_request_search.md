# Search Using the Square Catalog API

Square has two endpoints for searching their Catalog API. One of those endpoints has two mutually exclusive search options. So we have THREE classes.
It is not immediately apparent from the main Square doc that these searches are mutually exclusive. But it is mentioned on the
[CatalogQuery](https://developer.squareup.com/reference/square_2021-07-21/objects/CatalogQuery) page, concatenated to the list entry for "text_query" up
near the top of the page.

Our classes are:

For the [search-catalog-items endpoint](https://developer.squareup.com/reference/square/catalog-api/search-catalog-items)

- Catalog_Search_Items - Searches for catalog items or items variations

For the [search-catalog-objects endpoint](https://developer.squareup.com/reference/square/catalog-api/search-catalog-objects)

- These search for catalog objects of any type. These are mutually exclusive, thus the separation into two classes.
- Catalog_Search_Filter - search using key:value pairs
- Catalog_Search_Cross_Reference - Search using ONE array of ids to cross-reference

<br/>

# Catalog_Search_Cross_Reference & Catalog_Search_Filter

Square provides two mutually exclusive ways to search with a single endpoint. One way is to filter using different searchable properties and values. The other way
is to provide it an array of IDs for specific modifiers such as taxes or modifier_lists. So if you want all objects that use a taxes called "sales taxes"
you would find the Object ID of that taxes and then put that ID into the array. It would then return all objects that use that taxes. You cannot filter such a
request. You must use one type or the other. Square will reject a request which has an array of IDs along with any kind of refining details.

When looking at the Square docs, the 'query' property is where all the confusing stuff happens. Note that there are two broad mutually exclusive
categories of sub-properties.

- 'items*for*\*' - These are arrays of ids
- all the rest of them - these are key:value pairings

'items_for' properties are generated by Catalog_Search_Cross_Reference
The rest of them are generated by Catalog_Search_Filter

This is what a Catalog_Search_Cross_Reference request.body may look like:

```json
{
  "object_types": ["ITEM"],
  "query": {
    "items_for_item_options_query": {
      "item_option_ids": ["id1", "id2"]
    }
  },
  "limit": 100
}
```

This is what a Catalog_Search_Filter request.body may look like:

```json
{
  "object_types": ["ITEM"],
  "query": {
    "prefix_query": {
      "attribute_name": "name",
      "attribute_prefix": "vista"
    }
  },
  "limit": 100
}
```

Note that both classes have the same request.body structure, but that the query object takes a different form in each.

<br/>

## How to search

To restrict the type of object

- call the `yourVar.object_types().TYPE_OF_OBJECT()`
- use setter notation `yourVar.object_types = "ITEM"`

If Square Catalog has the object as a type, add that type in ALL_CAPS as a method call.
Your autocomplete will not recognize this. Some common calls look like"

```js
.object_types().ITEM_VARIATION()
.object_types().CATEGORY()
.object_types().ITEM()
```

You could also do something like below to get two types:
`.object_types().CATEGORY().object_types().ITEM_VARIATION()`

```js
const search = new Catalog_Search_Objects();
search.item;
search.variation;
search.name;
```

<br/>

## Catalog_Search_Objects_Super

The common elements between the two types of Catalog Object Search live here.
This sets the endpoint and method and has the configuration property for the auto generator.
It holds the following properties on the `._body` property:

- cursor
- include_related_objects
- begin_time
- object_types
- query

<br/>

## Catalog_Search_Objects_Filter

### What this class does

It lets you search for all objects that have certain values at certain keys. You can search just about any
writable property.

This class sets the `_body.query` property on Super.\
This is the class to use if:

- you want to **combine elements** to get a refined search. All the methods can be used
  to layer on additional criteria.
- you want to search for **deleted** objects

To use this class you will need to conform to the data structures specified by Square [CatalogQuery](https://developer.squareup.com/reference/square/objects/CatalogQuery)
. In general these are
objects with two or three properties. Usually you specify the property name you want to search and an expected value.
The property name has to be exactly the same, but the value can be exactly or partly the same.

### Adding an object type

You can directly access the setter:

```js
yourVar.object.type = "ITEM";
```

You can access the alias on the make method:

```js
yourVar.make().add_object_type("ITEM");
```

You can access one of the auto generated chain setters on the make method:

```js
yourVar.make().object_type().ITEM();
```

Make sure that you use ALLCAPS to reference the type. Any Square Catalog Object type is valid.

### make()

Chainable setter methods. Includes references to all the below methods plus one other.
The extra one is `add_object_type`
`make.add_object_type(type)`: takes a Catalog Object TYPE name as an argument. Adds that type
to the object_types array.

<br/>

## Chainable Methods

These are the methods you can use to build up a filter for your search. Any method that ends in `_query` corresponds directly
to the property names on the query property in the Square docs for [Search catalog objects](https://developer.squareup.com/reference/square/catalog-api/search-catalog-objects)
The outlines below show how the argument should be structured.

<br/>

> **NOTE:** if an arg property is not marked "// OPTIONAL" it is **REQUIRED**

### **exact_query(obj)**

```js
obj = {
  attribute_name: "some_property_name",
  attribute_value: "some value",
};
```

#### :warning: Will throw errors on

- The input is incorrectly formatted.
- either property is not of type "string"

### **set_query(obj)**

```js
obj = {
  attribute_name: "some_property_name",
  attribute_values: ["some value", "some other value"],
};
```

#### :warning: Will throw errors on

- The input is incorrectly formatted.
- attribute_name is not of type "string"
- attribute_values is not an array

### **prefix_query(obj)**

```js
obj = {
  attribute_name: "some_property_name",
  attribute_prefix: "some value",
};
```

#### :warning: Will throw errors on:

- The input is incorrectly formatted.
- either property is not of type "string"

### **range_query(obj)**

```js
obj = {
  attribute_name: "some_property_name",
  attribute_max_value: number, // OPTIONAL
  attribute_min_value: number, // OPTIONAL
};
```

#### :warning: Will throw errors on

- The input is incorrectly formatted.
- attribute_name is not of type "string"

### **sorted_attribute_query(obj)**

```js
obj = {
  attribute_name: "The attribute whose value is used as the sort key",
  initial_attribute_value:
    "The first attribute value to be returned by the query", // OPTIONAL
  sort_order: `"ASC" or "DESC"`, // OPTIONAL
};
```

#### :warning: Will throw errors on

- The input is incorrectly formatted.
- sort_order contains any value other than "ASC" or "DESC";

### **text_query(arr)**

Takes an array of \_no more than\* three strings. Throws an error on an empty array or if the array has a length greater than 3

```js
arr = ["word1", "word2", "word3"];
```

#### :warning: Will throw errors on

- The array passed has more than 3 elements.

### **text_query_add(word)**

Caches the keywords array if there is one. Makes a new array if not.
Adds the new word to the array.
Warning: If the array length is greater than 2, this method will remove every elment past the second before
adding the new word.

```js
word = "some word";
```

#### :warning: Will throw errors on

- None. See setter.

### **text_query_remove(word)**

If the word you pass it is in the text_query array, it removes that word.

```js
word = "some word";
```

This will be converted by the class to the format Square expects:

```js
keywords: {
  ["the", "values", "entered"];
}
```

#### :no_entry: Errors

- Will throw an error if there are no keywords or no keyword array.

<br/>

# Catalog_Search_Objects_Cross_Reference

### **What this class does**

It allows you to cross-reference objects with other objects they reference. For example, you may want to find
all products that use a particular taxes. That taxes will have its own unique object ID that is stored in all objects
that use it. This lets you find them.

You can use it to cross-reference items, items-variations, modifiers-lists, and taxes. You can only do it for one of those
types at a time. Attempting to add a second type of ID will clear the query object completely.

#### **How to USE**

If you want to add IDs one a time, pass the id as an argument to the appropriate make sub-method

If you want to add a batch of IDs all at once, collect them into an array and pass the array as an argument to the
appropriate make sub-method. (with this cross-reference only, you can also completely omit make() for adding ids)

The make submethods for single ids are:
-variations(id): for item_variations
-items(id): for items
-modifiers(id): for modifiers
-taxes(id): for taxes

The make submethods for single ids are add "concat\_" to the front of the other sub-method names

- concat_variations(array): for item_variations
- concat_items(array): for items
- concat_modifiers(array): for modifiers
- concat_taxes(array): for taxes

#### **Details**

### **Adding Single IDs**

1. `const xref = new Catalog_Search_Objects_Cross_Reference()`
2. `xref.make().variations("some id").variations("some other id") ...`

### **Adding An Array of IDs**

1. `const xref = new Catalog_Search_Objects_Cross_Reference()`
2. `xref.make().concat_variations(["some_id", "other_ids", ...])`

### **Item types**

You can chain these, as many times as you like. But only the one at the very end of the whole chain will work. Which means
that if you make a mistake and call the wrong one, just call the right one afterwards and all wil be good.

These set the value for you and are called without arguments.

- `make().object_types().items()`
- `make().object_types().variations()`
- `make().object_types()modifiers()`
- `make().object_types().taxes()`

<br/>

# Catalog_Search_Items

Use this class when you want to search only Items and Item-Variations
It is analogous to Square's [Search catalog items](https://developer.squareup.com/reference/square/catalog-api/search-catalog-items)

### **Sort Order**

Possible values are "ASC" _or_ "DESC". You can use one or the other.

**To use:**

- `.sort_order = "ASC";`
- `.sort_order = "DESC";`
- `.make().sort_order("ASC")`
- `.make().sort_order("DESC")`
- `.sortup()`
- `.sortdown()`

### **Stock Levels**

Search by whether you are completely or amost out of something. If you don't have inventory enabled for the items, this wil fudge up your search.
Can accept two values "OUT" and "LOW". You can use both at the same time.

**To use:**

- `.stock_levels = str;`
- `.make().stock_levels(str)`
- `.low()`
- `.out()`
- `.lowout()`
- `.outlow()`

`.lowout()` and `.outlow()` do exactly the same thing. They set the vaue to both "LOW" and "OUT".
Whichever one sticks in your brain is the correct one to use.

### **Text Filter**

It's what it sounds like. You give it a string, it looks for that string.

For items it searches the fields

- `name`
- `description`
- `abbreviation`

For items-variations it searches the fields

- `name`
- `sku`
- `upc`

**To use:**

- `.text_filter = str`
- `.make().text_filter(str)`
- `.text(str)`

### **Product Types**

You can limit your search to either "REGULAR" or "APPOINTMENTS_SERVICE"

It will only accept those two values. Any other input will throw an error.
To make it easy you can just all `.regular` or `.appt()` without arguments and the exact
value will be set.

**To use:**

- `.product_type = str`
- `.make().product_type(str)`
- `.regular()`
- `.appt()`

### **Category IDs**

Feed it the object ID of the category you want to filter by. It would be nice if we could just use the category name, but we can't, not allowed.

**To use:**

- `.category_ids = id;`
- `.make().category_ids(id)`
- `.category(id)`

### **Enabled Location IDs**

Feed it the object ID of the category you want to filter by.

**To use:**

- `.enabled_location_ids = id;`
- `.make().enabled_location_ids(id)`
- `.location(id)`

### **[Custom Attribute Filters](https://developer.squareup.com/reference/square/objects/CustomAttributeFilter)**

There is special make method for custom attribute filters.
make_custom_attribute_filter()
The sub-methods available are:

- custom_attribute_definition_id(id)
- key(str)
- string_filter(str)
- number_filter(min, max) - doesn't really matter what order you put the arguments, it will set the smaller one as min and the larger one as max.
- selection_uids_filter(str)
- bool_filter(boolean)
